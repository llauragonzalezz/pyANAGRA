Con la versión descargada de Github, ocurre lo siguiente:

OK 1) no cambia de idioma: cambio a inglés, arranco de nuevo, pero sigue en español 
OK 2) "Buscar" "A" (por ejemplo, en cualquiera de las grámáticas) da la excepción que pongo debajo. Sin embargo, "Buscar" y "Remplazar" funciona correctamente.

Traceback (most recent call last):
  File "/home/ezpeleta/Documents/TFG_TFM_PracticasEmpresa/TFG_Laura/github/ANAGRA/utils.py", line 148, in accept
    cursor = QTextCursor(self.text_grammar.document())
AttributeError: 'FindWindow' object has no attribute 'text_grammar'
Traceback (most recent call last):
  File "/home/ezpeleta/Documents/TFG_TFM_PracticasEmpresa/TFG_Laura/github/ANAGRA/utils.py", line 148, in accept
    cursor = QTextCursor(self.text_grammar.document())
AttributeError: 'FindWindow' object has no attribute 'text_grammar'

OK 3) "Compute First of sentential form" parece que no calcula nada

4) Con la siguiente gramática, la factorización a izda. da la excepción que pongo debajo
%%
S:
    | A B A
    | A 'd'
;

A:
    | 'a' B
;

B:
    | 'b' B 'c'
;

C: B 'm'
;

D:D
;

  File "interfaz.py", line 793, in removal_left_recursion
    gr, _ = grammar.removal_left_recursion(self.grammar)
  File "/home/ezpeleta/Documents/TFG_TFM_PracticasEmpresa/TFG_Laura/github/ANAGRA/grammar.py", line 151, in removal_left_recursion
    gr.productions[symbol_i].append(production_to_remplace + production[1:])
TypeError: unsupported operand type(s) for +: 'NoneType' and 'list'

OK 5) Pongo el "tabcount" a 4, pero parece que sigue siendo 8
6) Lo relativo a la gramática está en el menú "Grammar", pero aceptar la gramática está en el menú "Edit". Creo que estaría mejor en el primero, parece un poco fuera de lugar (debajo editar)
7) Parece que "Removal of cycles" no es correcto. Con la misma gramática de antes, da la siguiente gramática, que on es correcta (pues ahora D deriva epsilon, lo que no puede ser). Es posible que no se cumpla alguna precondición, o que haya fallo en la implementación
%%
%start S
%%

S: | A  B  A| A  'd';
A: | 'a'  B;
B: | 'b'  B  'c';
C: B  'm'| ;
D: ;

8) La forma normal de Greibach, con la misma gramática, da la excepción 

Traceback (most recent call last):
  File "/home/ezpeleta/Documents/TFG_TFM_PracticasEmpresa/TFG_Laura/github/ANAGRA/interfaz.py", line 837, in greibach_normal_form
    gr = grammar.greibach_normal_form(self.grammar)
  File "/home/ezpeleta/Documents/TFG_TFM_PracticasEmpresa/TFG_Laura/github/ANAGRA/grammar.py", line 587, in greibach_normal_form
    if production is not None and production[0] in gr.non_terminals:
IndexError: list index out of range

OK 9) Con la misma gramática, al probar "Parse LL(1)" da 
Traceback (most recent call last):
  File "/home/ezpeleta/Documents/TFG_TFM_PracticasEmpresa/TFG_Laura/github/ANAGRA/interfaz.py", line 42, in run
    table_LL1 = LL1.calculate_table(self.grammar)
  File "/home/ezpeleta/Documents/TFG_TFM_PracticasEmpresa/TFG_Laura/github/ANAGRA/LL1.py", line 70, in calculate_table
    for b in gr.terminals & follow_set[token]:
KeyError: 'C'
hola
1
2

Y, además, aparece ventana de "Calculando la ... SLR(1)" OK 
------------------------------------------------------------------
10) Mejorar algo el formato automática de salida. Al transformar lo siguiente con "leftFactoring"
%token c d
%%
S: C C;

C: c C;

C: d;

muestra

%start S
%token c d
%%

S: C  C;
C: c  C| d;

Dado que hab. se trabajará con gramáticas pequeñas, es mejor mostrarlo en el formato extendido

OK 11) Parece que no siempre redibuja bien: ver image_1.png y video_1

12) Con
%token c d
%%
S: C C;

C: c C;

C: d;

simular LL(1) da la excepción 

Traceback (most recent call last):
  File "/home/ezpeleta/Documents/TFG_TFM_PracticasEmpresa/TFG_Laura/github/ANAGRA/utils.py", line 102, in accept
    table, error = LL1.simulate(self.table_LL1, self.grammar, text + " $")
  File "/home/ezpeleta/Documents/TFG_TFM_PracticasEmpresa/TFG_Laura/github/ANAGRA/LL1.py", line 145, in simulate
    if table[x[0], sig_tok][0] != "error":
KeyError: ('S', 'cccccd$')
------------------------------------------------------------------
13) Errores en sitio equivocado (ver imagen_2)
OK 14) Ver video_3: aparecen varias situaciones de error
* parsing LL(1), pero mensaje dice SLR(1), y otros
* después de factorización a izda. da una gramática extraña.
15) Hay que limpiar todas las salidas por stdout/stderr que, claramente, son de "debugueo", como

hola1
{(0, 'c'): ['shift 2'], (0, 'd'): ['shift 3'], (4, '$'): ['accept'], (1, 'c'): ['shift 2'], (1, 'd'): ['shift 3'], (2, 'c'): ['shift 2'], (2, 'd'): ['shift 3'], (3, '$'): ['reduce C → d'], (3, 'c'): ['reduce C → d'], (3, 'd'): ['reduce C → d'], (5, '$'): ['reduce S → C C'], (6, '$'): ['reduce C → c C'], (6, 'c'): ['reduce C → c C'], (6, 'd'): ['reduce C → c C'], (0, '$'): ['ERROR'], (1, '$'): ['ERROR'], (2, '$'): ['ERROR'], (4, 'c'): ['ERROR'], (4, 'd'): ['ERROR'], (5, 'c'): ['ERROR'], (5, 'd'): ['ERROR']}
hola2
{(0, 'C'): 1, (0, 'S'): 4, (1, 'C'): 5, (2, 'C'): 6, (0, '$'): 'ERROR', (0, 'S*'): 'ERROR', (1, '$'): 'ERROR', (1, 'S'): 'ERROR', (1, 'S*'): 'ERROR', (2, '$'): 'ERROR', (2, 'S'): 'ERROR', (2, 'S*'): 'ERROR', (3, '$'): 'ERROR', (3, 'C'): 'ERROR', (3, 'S'): 'ERROR', (3, 'S*'): 'ERROR', (4, '$'): 'ERROR', (4, 'C'): 'ERROR', (4, 'S'): 'ERROR', (4, 'S*'): 'ERROR', (5, '$'): 'ERROR', (5, 'C'): 'ERROR', (5, 'S'): 'ERROR', (5, 'S*'): 'ERROR', (6, '$'): 'ERROR', (6, 'C'): 'ERROR', (6, 'S'): 'ERROR', (6, 'S*'): 'ERROR'}

implementación propia de un analizador descendente (recursivo o por tabla)


parse text sin espacios
------------------------------------------------------------------
15) Tenemos que ver los vídeos conjuntamente y resolver las cuestiones que muestran

OK 16) En la simulación, la pila estaría mejor en vertical






